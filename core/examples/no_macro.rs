//! Examples: no_macro
//!
//! This showcases how to use this library without using the macro
//! to generate the rendering adapter for your project.
//!
//! It works by manually defining the dioxus_elements module + the elements enum + implementing the
//! DioxusBevyTemplateNode trait on the elements enum to provide all the logic to spawn and mutate
//! the elements.  It's a bit of a pain because a few things need to be kept in sync.
//!
//! 1. If you define an attribute in dioxus_elements you must handle it in `set_attribute`.
//! 2. If you define an element in `dioxus_elements` you must handle it in `from_dioxus` and `spawn`
use core::panic;

use bevy::prelude::*;
use bevy_inspector_egui::quick::WorldInspectorPlugin;
use dioxus_bevy_core::prelude::*;
use dioxus_bevy_core::{DioxusBevyPlugin, DioxusBevyRootComponent};

/// This is a module that has to be in-scope for dioxus's rsx! macro to work.
/// It provides typechecking + completions while writing rsx.
///
/// You must have a variant in the [MyAdapter] enum for each element struct defined here.
/// You must handle the string in [set_attribute] for each attribute defined here.
pub mod dioxus_elements {
    pub type AttributeDescription = (&'static str, Option<&'static str>, bool);
    const NAME_SPACE: Option<&'static str> = Some("dioxus_bevy");

    #[allow(non_camel_case_types)]
    pub struct node;
    #[allow(non_upper_case_globals)]
    impl node {
        pub const TAG_NAME: &'static str = "node";
        pub const NAME_SPACE: Option<&'static str> = NAME_SPACE;
        pub const translation: AttributeDescription = ("translation", None, false);
        pub const translation_x: AttributeDescription = ("translation_x", None, false);
        pub const translation_y: AttributeDescription = ("translation_y", None, false);
        pub const translation_z: AttributeDescription = ("translation_z", None, false);
        pub const euler_x: AttributeDescription = ("euler_x", None, false);
    }
}

#[derive(Clone)]
/// Adapter is an enum containing all of the different element types
pub enum MyAdapter {
    Node { children: Box<[Self]> },
}

/// You must implement this trait that controls how a dioxus template node is created (from a dioxus
/// template node), how it is spawned, and how attributes are applied to the template node.
impl DioxusBevyTemplateNode for MyAdapter {
    /// This method receives a dioxus template node and returns an enum variant of the element type
    /// you want to spawn.
    fn from_dioxus(node: &TemplateNode) -> Self {
        match node {
            TemplateNode::Element {
                tag: "node",
                namespace: Some("dioxus_bevy"),
                attrs: _,
                children,
            } => {
                let children = children.iter().map(Self::from_dioxus).collect();

                Self::Node { children }
            }
            TemplateNode::Text { text } => {
                todo!("TemplateNode::Text");
                // Self::IntrinsicTextNode(Text::from_section(*text, TextStyle::default()))
            }
            TemplateNode::Dynamic { id: _ } => {
                todo!("TemplateNode::Dynamic");
                // Self::Node {
                //     style: StyleComponents::default(),
                //     children: Box::new([]),
                // }
            }
            TemplateNode::DynamicText { id: _ } => {
                todo!("TemplateNode::DynamicText");
                // Self::IntrinsicTextNode(Text::from_section("", TextStyle::default()))
            }
            TemplateNode::Element {
                tag,
                namespace: None,
                ..
            } => {
                panic!("Encountered unsupported bevy_dioxus tag `{tag}`.")
            }
            TemplateNode::Element {
                tag,
                namespace: Some(namespace),
                ..
            } => {
                panic!("Encountered unsupported bevy_dioxus tag `{namespace}::{tag}`.")
            }
        }
    }
    /// This method spawns a given element type by matching against itself.
    fn spawn(&self, world: &mut World) -> Entity {
        match self {
            Self::Node { children } => {
                let children = children
                    .iter()
                    .map(|child| child.spawn(world))
                    .collect::<Box<[_]>>();

                let mut entity_builder = world.spawn_empty();
                entity_builder.insert((Transform::default(), GlobalTransform::default()));
                entity_builder.push_children(&children);
                let entity = entity_builder.id();
                println!("Spawned BevyTemplateNode::Node with id {entity:?}");
                entity
            }
        }
    }

    /// This method applies an attribute to an entity and will be auto generated by the macro.
    fn apply_attribute(
        mut entity_mut: EntityWorldMut,
        name: &'static str,
        value: &dioxus_core::AttributeValue,
    ) {
        match name {
            "translation" => {
                let value = value.as_concrete::<Vec3>().copied();
                entity_mut.get_mut::<Transform>().unwrap().translation =
                    value.unwrap_or_else(Vec3::default);
            }
            "translation_x" => {
                entity_mut.get_mut::<Transform>().unwrap().translation.x =
                    value.as_f32().unwrap_or(0.)
            }
            "translation_y" => {
                entity_mut.get_mut::<Transform>().unwrap().translation.y =
                    value.as_f32().unwrap_or(0.)
            }
            "translation_z" => {
                entity_mut.get_mut::<Transform>().unwrap().translation.z =
                    value.as_f32().unwrap_or(0.)
            }
            "euler_x" => {
                let mut prev_transform = entity_mut.get_mut::<Transform>().unwrap();
                let prev = prev_transform.rotation.to_euler(EulerRot::XYZ);
                prev_transform.rotation = Quat::from_euler(EulerRot::XYZ, value.as_f32().unwrap_or(0.), prev.1, prev.2)
            }
            name => {
                panic!("Unexpected attribute {name} with value {value:?}");
            }
        }
    }
}

#[derive(Resource)]
pub struct State {
    pressed_count: usize,
}
pub fn main() {
    let mut app = App::new();
    app.add_plugins(DefaultPlugins);
    app.add_plugins(DioxusBevyPlugin::<MyAdapter>::default());
    app.add_plugins(WorldInspectorPlugin::new());
    app.add_systems(Startup, setup);

    app.insert_resource(State { pressed_count: 0 });
    app.add_systems(Update, update);

    app.run();
}

#[component]
pub fn root() -> Element {
    println!("Re-rendering root node");

    let state = DBHooks::<MyAdapter>::use_bevy_resource::<State>();
    rsx! {
        node {
            translation_x: state.pressed_count as f64,
            translation_y: 1.0,
            translation_z: 0.5,
            node {
                translation_x: state.pressed_count as f64,
                euler_x: 20.
            }
        }
    }
}

pub fn setup(mut commands: Commands) {
    commands.spawn((
        Transform::default(),
        GlobalTransform::default(),
        DioxusBevyRootComponent(root),
    ));
}

pub fn update(button_state: Res<ButtonInput<KeyCode>>, mut state: ResMut<State>) {
    if button_state.pressed(KeyCode::Space) {
        state.pressed_count += 1
    }
}
